# Экспоненциальный поиск

Задача с платформы All Cups ([ссылка](https://cups.online/ru/workareas/education_2277/1238/2398/)).

## Описание задачи

Дан отсортированный по возрастанию массив целых чисел и некоторое целое число. Ваша задача — найти минимальный диапазон индексов (подмассив), в котором может находиться заданное число. Используйте метод экспоненциального поиска.

## Формат входных данных

- **Первая строка**: число N — количество элементов в массиве
- **Вторая строка**: массив из N целых чисел, разделённых пробелами
- **Третья строка**: целое число `target`, для которого нужно найти диапазон

## Формат выходных данных

Программа должна вывести два числа через пробел, представляющие диапазон индексов, где может находиться число `target`:
- Если число находится в массиве, это должен быть диапазон, содержащий индекс числа
- Если число отсутствует, диапазон должен содержать индексы, где оно могло бы быть вставлено

## Пример

### Входные данные
```
11
8 11 12 16 18 21 33 36 48 54 63
16
```

### Выходные данные
```
2 4
```

### Пояснение
Число 16 находится в подмассиве от индекса 2 до индекса 4.

## Требования к реализации

- Используйте метод экспоненциального поиска для эффективного нахождения диапазона
- Алгоритм должен иметь временную сложность O(log n)
- Учитывайте, что массив отсортирован по возрастанию

### Краевые случаи 

В условии задачи не описано, как функция должна вести себя при:
- `array[0] > target`
- `array[-1] < target`
- `array = [] пустой массив`

Случай
```
    array = [1, 2, 3, 4, 5, 6, 7, 8]
    target = 1
```
тоже не описан, и потенциально возможны ответы: `[0, 0]` и `[0, 1]`.

Судя по тестам оценивающим решение, верным вариантом является `[0, 1]`.

# Решение

## Подход и алгоритм

Решение использует **фазу экспоненциального расширения** из паттерна экспоненциального поиска для эффективного нахождения диапазона индексов, где может находиться целевое число.

### Основные шаги алгоритма:

1. **Инициализация**: Начинаем с `low = 1` (индекс 1, а не 0)
2. **Экспоненциальное расширение**: Удваиваем `low` (`low *= 2`) до тех пор, пока `array[low] < target`
3. **Обработка выхода за границы**: Если `low` превышает длину массива, корректируем диапазон:
   - Устанавливаем `high = len(array) - 1`
   - Возвращаем `[low // 2, high]`
4. **Формирование диапазона**: Когда `array[low] >= target`, возвращаем `[low // 2, low]`

### Сложность:

- **Временная сложность**: O(log(m)), где m - номер индекса элемента в массиве или индекса, где могло бы располагаться число `target`, если оно отсутствует
- **Пространственная сложность**: O(1) (используется постоянное количество дополнительной памяти)

### Особенности реализации:

- Алгоритм начинает поиск с индекса 1, а не 0, для упрощения логики экспоненциального расширения
- При выходе за границы массива происходит автоматическая корректировка диапазона
- Возвращаемый диапазон всегда содержит индексы, где может находиться `target` или где оно могло бы быть вставлено

## Тестовые сценарии

Решение проверено на следующих тестовых случаях:

1. **target внутри массива**:
   - `array = [1, 2, 3, 4, 5, 6, 7, 8]`, `target = 5`
   - Ожидаемый результат: `[2, 4]`
   - Диапазон содержит индекс элемента 5

2. **target у границы массива**:
   - `array = [1, 2, 3, 4, 5, 6, 7, 8]`, `target = 6`
   - Ожидаемый результат: `[4, 7]`
   - Происходит выход за границы при экспоненциальном расширении

3. **target на первом элементе**:
   - `array = [1, 2, 3, 4, 5, 6, 7, 8]`, `target = 1`
   - Ожидаемый результат: `[0, 1]`
   - Специальный случай, когда target находится на нулевом индексе